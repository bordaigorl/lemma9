# Generated from /home/fms/Daten/B-Praktika Jobs/ImperialCollege/ideal-completions-security-code/parser/Pi.g4 by ANTLR 4.7
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"(\u015c\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t")
        buf.write(u"\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$")
        buf.write(u"\t$\4%\t%\4&\t&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\3\2\3")
        buf.write(u"\2\3\2\5\2Z\n\2\3\2\3\2\5\2^\n\2\3\2\3\2\5\2b\n\2\3\2")
        buf.write(u"\3\2\5\2f\n\2\3\2\3\2\3\3\3\3\3\3\7\3m\n\3\f\3\16\3p")
        buf.write(u"\13\3\3\4\3\4\3\4\3\4\3\4\3\5\3\5\6\5y\n\5\r\5\16\5z")
        buf.write(u"\3\5\3\5\3\6\3\6\3\7\3\7\3\7\7\7\u0084\n\7\f\7\16\7\u0087")
        buf.write(u"\13\7\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write(u"\5\t\u0095\n\t\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3")
        buf.write(u"\f\7\f\u00a0\n\f\f\f\16\f\u00a3\13\f\3\r\3\r\3\r\3\r")
        buf.write(u"\3\r\3\r\3\r\3\r\5\r\u00ad\n\r\3\16\3\16\3\16\3\16\3")
        buf.write(u"\16\3\17\3\17\3\17\3\20\3\20\3\20\3\20\3\20\5\20\u00bc")
        buf.write(u"\n\20\3\21\3\21\3\21\3\21\3\21\5\21\u00c3\n\21\3\22\3")
        buf.write(u"\22\3\23\3\23\3\23\7\23\u00ca\n\23\f\23\16\23\u00cd\13")
        buf.write(u"\23\3\24\3\24\3\24\3\24\3\24\3\24\3\25\3\25\3\25\3\25")
        buf.write(u"\5\25\u00d9\n\25\3\25\5\25\u00dc\n\25\3\25\3\25\3\26")
        buf.write(u"\3\26\3\26\7\26\u00e3\n\26\f\26\16\26\u00e6\13\26\3\27")
        buf.write(u"\3\27\3\30\3\30\3\31\3\31\3\31\7\31\u00ef\n\31\f\31\16")
        buf.write(u"\31\u00f2\13\31\3\32\3\32\3\33\3\33\3\34\3\34\5\34\u00fa")
        buf.write(u"\n\34\3\34\3\34\7\34\u00fe\n\34\f\34\16\34\u0101\13\34")
        buf.write(u"\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\37\3")
        buf.write(u"\37\3 \3 \3 \3 \3!\3!\3!\3!\3!\3!\5!\u0118\n!\3\"\3\"")
        buf.write(u"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\3#\5#\u0128\n#\3$\3")
        buf.write(u"$\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3&\3&\3&\3&\3\'\3\'\3")
        buf.write(u"\'\3\'\3\'\3\'\3(\3(\3(\3(\3(\3(\3(\5(\u0147\n(\3)\3")
        buf.write(u")\3)\3)\3)\3)\3*\3*\3*\3*\3*\3*\3+\3+\7+\u0157\n+\f+")
        buf.write(u"\16+\u015a\13+\3+\2\2,\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write(u"\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRT\2\3\4\2")
        buf.write(u"\4\4\35\36\2\u0155\2Y\3\2\2\2\4n\3\2\2\2\6q\3\2\2\2\b")
        buf.write(u"v\3\2\2\2\n~\3\2\2\2\f\u0085\3\2\2\2\16\u0088\3\2\2\2")
        buf.write(u"\20\u0094\3\2\2\2\22\u0096\3\2\2\2\24\u0098\3\2\2\2\26")
        buf.write(u"\u009c\3\2\2\2\30\u00ac\3\2\2\2\32\u00ae\3\2\2\2\34\u00b3")
        buf.write(u"\3\2\2\2\36\u00b6\3\2\2\2 \u00bd\3\2\2\2\"\u00c4\3\2")
        buf.write(u"\2\2$\u00c6\3\2\2\2&\u00ce\3\2\2\2(\u00d4\3\2\2\2*\u00df")
        buf.write(u"\3\2\2\2,\u00e7\3\2\2\2.\u00e9\3\2\2\2\60\u00eb\3\2\2")
        buf.write(u"\2\62\u00f3\3\2\2\2\64\u00f5\3\2\2\2\66\u00f9\3\2\2\2")
        buf.write(u"8\u0102\3\2\2\2:\u0104\3\2\2\2<\u010b\3\2\2\2>\u010d")
        buf.write(u"\3\2\2\2@\u0117\3\2\2\2B\u0119\3\2\2\2D\u0127\3\2\2\2")
        buf.write(u"F\u0129\3\2\2\2H\u012f\3\2\2\2J\u0135\3\2\2\2L\u0139")
        buf.write(u"\3\2\2\2N\u0146\3\2\2\2P\u0148\3\2\2\2R\u014e\3\2\2\2")
        buf.write(u"T\u0154\3\2\2\2VW\5\b\5\2WX\5T+\2XZ\3\2\2\2YV\3\2\2\2")
        buf.write(u"YZ\3\2\2\2Z[\3\2\2\2[]\5\f\7\2\\^\5T+\2]\\\3\2\2\2]^")
        buf.write(u"\3\2\2\2^_\3\2\2\2_a\5\4\3\2`b\5T+\2a`\3\2\2\2ab\3\2")
        buf.write(u"\2\2bc\3\2\2\2ce\5\20\t\2df\5T+\2ed\3\2\2\2ef\3\2\2\2")
        buf.write(u"fg\3\2\2\2gh\7\2\2\3h\3\3\2\2\2ij\5\6\4\2jk\5T+\2km\3")
        buf.write(u"\2\2\2li\3\2\2\2mp\3\2\2\2nl\3\2\2\2no\3\2\2\2o\5\3\2")
        buf.write(u"\2\2pn\3\2\2\2qr\5\"\22\2rs\7&\2\2st\5\20\t\2tu\7 \2")
        buf.write(u"\2u\7\3\2\2\2vx\7\6\2\2wy\5\n\6\2xw\3\2\2\2yz\3\2\2\2")
        buf.write(u"zx\3\2\2\2z{\3\2\2\2{|\3\2\2\2|}\7 \2\2}\t\3\2\2\2~\177")
        buf.write(u"\7\3\2\2\177\13\3\2\2\2\u0080\u0081\5\16\b\2\u0081\u0082")
        buf.write(u"\5T+\2\u0082\u0084\3\2\2\2\u0083\u0080\3\2\2\2\u0084")
        buf.write(u"\u0087\3\2\2\2\u0085\u0083\3\2\2\2\u0085\u0086\3\2\2")
        buf.write(u"\2\u0086\r\3\2\2\2\u0087\u0085\3\2\2\2\u0088\u0089\5")
        buf.write(u"\36\20\2\u0089\u008a\7%\2\2\u008a\u008b\5$\23\2\u008b")
        buf.write(u"\u008c\7 \2\2\u008c\17\3\2\2\2\u008d\u0095\5\22\n\2\u008e")
        buf.write(u"\u008f\5\24\13\2\u008f\u0090\7\24\2\2\u0090\u0091\5\26")
        buf.write(u"\f\2\u0091\u0092\7\25\2\2\u0092\u0095\3\2\2\2\u0093\u0095")
        buf.write(u"\5\26\f\2\u0094\u008d\3\2\2\2\u0094\u008e\3\2\2\2\u0094")
        buf.write(u"\u0093\3\2\2\2\u0095\21\3\2\2\2\u0096\u0097\7\34\2\2")
        buf.write(u"\u0097\23\3\2\2\2\u0098\u0099\7\t\2\2\u0099\u009a\5*")
        buf.write(u"\26\2\u009a\u009b\7\37\2\2\u009b\25\3\2\2\2\u009c\u00a1")
        buf.write(u"\5\30\r\2\u009d\u009e\7\30\2\2\u009e\u00a0\5\30\r\2\u009f")
        buf.write(u"\u009d\3\2\2\2\u00a0\u00a3\3\2\2\2\u00a1\u009f\3\2\2")
        buf.write(u"\2\u00a1\u00a2\3\2\2\2\u00a2\27\3\2\2\2\u00a3\u00a1\3")
        buf.write(u"\2\2\2\u00a4\u00ad\5> \2\u00a5\u00ad\5 \21\2\u00a6\u00ad")
        buf.write(u"\5\34\17\2\u00a7\u00a8\7\24\2\2\u00a8\u00a9\5\20\t\2")
        buf.write(u"\u00a9\u00aa\7\25\2\2\u00aa\u00ad\3\2\2\2\u00ab\u00ad")
        buf.write(u"\5\32\16\2\u00ac\u00a4\3\2\2\2\u00ac\u00a5\3\2\2\2\u00ac")
        buf.write(u"\u00a6\3\2\2\2\u00ac\u00a7\3\2\2\2\u00ac\u00ab\3\2\2")
        buf.write(u"\2\u00ad\31\3\2\2\2\u00ae\u00af\7\24\2\2\u00af\u00b0")
        buf.write(u"\5\20\t\2\u00b0\u00b1\7\25\2\2\u00b1\u00b2\7\n\2\2\u00b2")
        buf.write(u"\33\3\2\2\2\u00b3\u00b4\5 \21\2\u00b4\u00b5\7\n\2\2\u00b5")
        buf.write(u"\35\3\2\2\2\u00b6\u00bb\5\"\22\2\u00b7\u00b8\7\31\2\2")
        buf.write(u"\u00b8\u00b9\5\64\33\2\u00b9\u00ba\7\32\2\2\u00ba\u00bc")
        buf.write(u"\3\2\2\2\u00bb\u00b7\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc")
        buf.write(u"\37\3\2\2\2\u00bd\u00c2\5\"\22\2\u00be\u00bf\7\31\2\2")
        buf.write(u"\u00bf\u00c0\5.\30\2\u00c0\u00c1\7\32\2\2\u00c1\u00c3")
        buf.write(u"\3\2\2\2\u00c2\u00be\3\2\2\2\u00c2\u00c3\3\2\2\2\u00c3")
        buf.write(u"!\3\2\2\2\u00c4\u00c5\t\2\2\2\u00c5#\3\2\2\2\u00c6\u00cb")
        buf.write(u"\5&\24\2\u00c7\u00c8\7#\2\2\u00c8\u00ca\5&\24\2\u00c9")
        buf.write(u"\u00c7\3\2\2\2\u00ca\u00cd\3\2\2\2\u00cb\u00c9\3\2\2")
        buf.write(u"\2\u00cb\u00cc\3\2\2\2\u00cc%\3\2\2\2\u00cd\u00cb\3\2")
        buf.write(u"\2\2\u00ce\u00cf\5(\25\2\u00cf\u00d0\7\37\2\2\u00d0\u00d1")
        buf.write(u"\7\24\2\2\u00d1\u00d2\5\20\t\2\u00d2\u00d3\7\25\2\2\u00d3")
        buf.write(u"\'\3\2\2\2\u00d4\u00d8\7$\2\2\u00d5\u00d6\5\64\33\2\u00d6")
        buf.write(u"\u00d7\7\"\2\2\u00d7\u00d9\3\2\2\2\u00d8\u00d5\3\2\2")
        buf.write(u"\2\u00d8\u00d9\3\2\2\2\u00d9\u00db\3\2\2\2\u00da\u00dc")
        buf.write(u"\5N(\2\u00db\u00da\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc")
        buf.write(u"\u00dd\3\2\2\2\u00dd\u00de\7\25\2\2\u00de)\3\2\2\2\u00df")
        buf.write(u"\u00e4\5,\27\2\u00e0\u00e1\7\33\2\2\u00e1\u00e3\5,\27")
        buf.write(u"\2\u00e2\u00e0\3\2\2\2\u00e3\u00e6\3\2\2\2\u00e4\u00e2")
        buf.write(u"\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5+\3\2\2\2\u00e6\u00e4")
        buf.write(u"\3\2\2\2\u00e7\u00e8\7\3\2\2\u00e8-\3\2\2\2\u00e9\u00ea")
        buf.write(u"\5\60\31\2\u00ea/\3\2\2\2\u00eb\u00f0\5\62\32\2\u00ec")
        buf.write(u"\u00ed\7\33\2\2\u00ed\u00ef\5\62\32\2\u00ee\u00ec\3\2")
        buf.write(u"\2\2\u00ef\u00f2\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1")
        buf.write(u"\3\2\2\2\u00f1\61\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f3\u00f4")
        buf.write(u"\5@!\2\u00f4\63\3\2\2\2\u00f5\u00f6\5\66\34\2\u00f6\65")
        buf.write(u"\3\2\2\2\u00f7\u00fa\58\35\2\u00f8\u00fa\5:\36\2\u00f9")
        buf.write(u"\u00f7\3\2\2\2\u00f9\u00f8\3\2\2\2\u00fa\u00ff\3\2\2")
        buf.write(u"\2\u00fb\u00fc\7\33\2\2\u00fc\u00fe\5\66\34\2\u00fd\u00fb")
        buf.write(u"\3\2\2\2\u00fe\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff")
        buf.write(u"\u0100\3\2\2\2\u0100\67\3\2\2\2\u0101\u00ff\3\2\2\2\u0102")
        buf.write(u"\u0103\7\3\2\2\u01039\3\2\2\2\u0104\u0105\7\24\2\2\u0105")
        buf.write(u"\u0106\58\35\2\u0106\u0107\7\"\2\2\u0107\u0108\7\b\2")
        buf.write(u"\2\u0108\u0109\5<\37\2\u0109\u010a\7\25\2\2\u010a;\3")
        buf.write(u"\2\2\2\u010b\u010c\7\5\2\2\u010c=\3\2\2\2\u010d\u010e")
        buf.write(u"\7\26\2\2\u010e\u010f\5@!\2\u010f\u0110\7\27\2\2\u0110")
        buf.write(u"?\3\2\2\2\u0111\u0118\5L\'\2\u0112\u0118\5D#\2\u0113")
        buf.write(u"\u0118\5F$\2\u0114\u0118\5H%\2\u0115\u0118\5J&\2\u0116")
        buf.write(u"\u0118\5B\"\2\u0117\u0111\3\2\2\2\u0117\u0112\3\2\2\2")
        buf.write(u"\u0117\u0113\3\2\2\2\u0117\u0114\3\2\2\2\u0117\u0115")
        buf.write(u"\3\2\2\2\u0117\u0116\3\2\2\2\u0118A\3\2\2\2\u0119\u011a")
        buf.write(u"\7\3\2\2\u011aC\3\2\2\2\u011b\u011c\7\16\2\2\u011c\u011d")
        buf.write(u"\5@!\2\u011d\u011e\7\33\2\2\u011e\u011f\5@!\2\u011f\u0120")
        buf.write(u"\7\25\2\2\u0120\u0128\3\2\2\2\u0121\u0122\7\21\2\2\u0122")
        buf.write(u"\u0123\5@!\2\u0123\u0124\7\22\2\2\u0124\u0125\7\23\2")
        buf.write(u"\2\u0125\u0126\5@!\2\u0126\u0128\3\2\2\2\u0127\u011b")
        buf.write(u"\3\2\2\2\u0127\u0121\3\2\2\2\u0128E\3\2\2\2\u0129\u012a")
        buf.write(u"\7\13\2\2\u012a\u012b\5@!\2\u012b\u012c\7\33\2\2\u012c")
        buf.write(u"\u012d\5@!\2\u012d\u012e\7\25\2\2\u012eG\3\2\2\2\u012f")
        buf.write(u"\u0130\7\f\2\2\u0130\u0131\5@!\2\u0131\u0132\7\33\2\2")
        buf.write(u"\u0132\u0133\5@!\2\u0133\u0134\7\25\2\2\u0134I\3\2\2")
        buf.write(u"\2\u0135\u0136\7\r\2\2\u0136\u0137\5@!\2\u0137\u0138")
        buf.write(u"\7\25\2\2\u0138K\3\2\2\2\u0139\u013a\7\24\2\2\u013a\u013b")
        buf.write(u"\5@!\2\u013b\u013c\7\33\2\2\u013c\u013d\5@!\2\u013d\u013e")
        buf.write(u"\7\25\2\2\u013eM\3\2\2\2\u013f\u0147\5L\'\2\u0140\u0147")
        buf.write(u"\5D#\2\u0141\u0147\5P)\2\u0142\u0147\5R*\2\u0143\u0147")
        buf.write(u"\5J&\2\u0144\u0147\5B\"\2\u0145\u0147\58\35\2\u0146\u013f")
        buf.write(u"\3\2\2\2\u0146\u0140\3\2\2\2\u0146\u0141\3\2\2\2\u0146")
        buf.write(u"\u0142\3\2\2\2\u0146\u0143\3\2\2\2\u0146\u0144\3\2\2")
        buf.write(u"\2\u0146\u0145\3\2\2\2\u0147O\3\2\2\2\u0148\u0149\7\17")
        buf.write(u"\2\2\u0149\u014a\5N(\2\u014a\u014b\7\33\2\2\u014b\u014c")
        buf.write(u"\5N(\2\u014c\u014d\7\25\2\2\u014dQ\3\2\2\2\u014e\u014f")
        buf.write(u"\7\20\2\2\u014f\u0150\5N(\2\u0150\u0151\7\33\2\2\u0151")
        buf.write(u"\u0152\5N(\2\u0152\u0153\7\25\2\2\u0153S\3\2\2\2\u0154")
        buf.write(u"\u0158\7!\2\2\u0155\u0157\7!\2\2\u0156\u0155\3\2\2\2")
        buf.write(u"\u0157\u015a\3\2\2\2\u0158\u0156\3\2\2\2\u0158\u0159")
        buf.write(u"\3\2\2\2\u0159U\3\2\2\2\u015a\u0158\3\2\2\2\31Y]aenz")
        buf.write(u"\u0085\u0094\u00a1\u00ac\u00bb\u00c2\u00cb\u00d8\u00db")
        buf.write(u"\u00e4\u00f0\u00f9\u00ff\u0117\u0127\u0146\u0158")
        return buf.getvalue()


class PiParser ( Parser ):

    grammarFileName = "Pi.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'#global'", u"'//'", u"'size '", u"'new '", u"'^w'", 
                     u"'aenc('", u"'sign('", u"'pub('", u"'enc('", u"'adec('", 
                     u"'veri('", u"'{'", u"'}'", u"'_'", u"'('", u"')'", 
                     u"'<'", u"'>'", u"'||'", u"'['", u"']'", u"','", u"'STOP'", 
                     u"'Secret'", u"'Leak'", u"'.'", u"';'", u"'\n'", u"':'", 
                     u"'+'", u"'in('", u"':='", u"'='" ]

    symbolicNames = [ u"<INVALID>", u"NAME", u"PROCID", u"NUMBER", u"GLOBAL", 
                      u"DOUBLESLASH", u"SIZE", u"NEWOP", u"OMEGA", u"AENCOP", 
                      u"SIGNOP", u"PUBOP", u"ENCOP", u"ADECOP", u"VERIOP", 
                      u"CURLOP", u"CURLCL", u"UNDER", u"PAROP", u"PARCL", 
                      u"FROP", u"FRCL", u"PARA", u"BRAOP", u"BRACL", u"COMMA", 
                      u"ZERO", u"SECRET", u"LEAK", u"DOT", u"SEM", u"NEWLINE", 
                      u"COL", u"CHOICEOP", u"INOP", u"DEF", u"EQ", u"WS", 
                      u"COMMENTS" ]

    RULE_program = 0
    RULE_helpers = 1
    RULE_helper = 2
    RULE_globalnames = 3
    RULE_globalname = 4
    RULE_definitions = 5
    RULE_definition = 6
    RULE_limit = 7
    RULE_nullprocess = 8
    RULE_newnames = 9
    RULE_parallels = 10
    RULE_comp = 11
    RULE_sublimit = 12
    RULE_iterproccall = 13
    RULE_proccalldef = 14
    RULE_processcall = 15
    RULE_procid = 16
    RULE_actions = 17
    RULE_action = 18
    RULE_inputpattern = 19
    RULE_names = 20
    RULE_newname = 21
    RULE_listofargs = 22
    RULE_arguments = 23
    RULE_argument = 24
    RULE_listofvars = 25
    RULE_variables = 26
    RULE_variable = 27
    RULE_sizedvar = 28
    RULE_size = 29
    RULE_msgout = 30
    RULE_msg = 31
    RULE_basicmsg = 32
    RULE_encrymsg = 33
    RULE_aencrymsg = 34
    RULE_signmsg = 35
    RULE_pubkeymsg = 36
    RULE_pairmsg = 37
    RULE_pattern = 38
    RULE_adecpattern = 39
    RULE_veripattern = 40
    RULE_newlines = 41

    ruleNames =  [ u"program", u"helpers", u"helper", u"globalnames", u"globalname", 
                   u"definitions", u"definition", u"limit", u"nullprocess", 
                   u"newnames", u"parallels", u"comp", u"sublimit", u"iterproccall", 
                   u"proccalldef", u"processcall", u"procid", u"actions", 
                   u"action", u"inputpattern", u"names", u"newname", u"listofargs", 
                   u"arguments", u"argument", u"listofvars", u"variables", 
                   u"variable", u"sizedvar", u"size", u"msgout", u"msg", 
                   u"basicmsg", u"encrymsg", u"aencrymsg", u"signmsg", u"pubkeymsg", 
                   u"pairmsg", u"pattern", u"adecpattern", u"veripattern", 
                   u"newlines" ]

    EOF = Token.EOF
    NAME=1
    PROCID=2
    NUMBER=3
    GLOBAL=4
    DOUBLESLASH=5
    SIZE=6
    NEWOP=7
    OMEGA=8
    AENCOP=9
    SIGNOP=10
    PUBOP=11
    ENCOP=12
    ADECOP=13
    VERIOP=14
    CURLOP=15
    CURLCL=16
    UNDER=17
    PAROP=18
    PARCL=19
    FROP=20
    FRCL=21
    PARA=22
    BRAOP=23
    BRACL=24
    COMMA=25
    ZERO=26
    SECRET=27
    LEAK=28
    DOT=29
    SEM=30
    NEWLINE=31
    COL=32
    CHOICEOP=33
    INOP=34
    DEF=35
    EQ=36
    WS=37
    COMMENTS=38

    def __init__(self, input, output=sys.stdout):
        super(PiParser, self).__init__(input, output=output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ProgramContext, self).__init__(parent, invokingState)
            self.parser = parser

        def definitions(self):
            return self.getTypedRuleContext(PiParser.DefinitionsContext,0)


        def helpers(self):
            return self.getTypedRuleContext(PiParser.HelpersContext,0)


        def limit(self):
            return self.getTypedRuleContext(PiParser.LimitContext,0)


        def EOF(self):
            return self.getToken(PiParser.EOF, 0)

        def globalnames(self):
            return self.getTypedRuleContext(PiParser.GlobalnamesContext,0)


        def newlines(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.NewlinesContext)
            else:
                return self.getTypedRuleContext(PiParser.NewlinesContext,i)


        def getRuleIndex(self):
            return PiParser.RULE_program

        def enterRule(self, listener):
            if hasattr(listener, "enterProgram"):
                listener.enterProgram(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProgram"):
                listener.exitProgram(self)




    def program(self):

        localctx = PiParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PiParser.GLOBAL:
                self.state = 84
                self.globalnames()
                self.state = 85
                self.newlines()


            self.state = 89
            self.definitions()
            self.state = 91
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.state = 90
                self.newlines()


            self.state = 93
            self.helpers()
            self.state = 95
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PiParser.NEWLINE:
                self.state = 94
                self.newlines()


            self.state = 97
            self.limit()
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PiParser.NEWLINE:
                self.state = 98
                self.newlines()


            self.state = 101
            self.match(PiParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HelpersContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.HelpersContext, self).__init__(parent, invokingState)
            self.parser = parser

        def helper(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.HelperContext)
            else:
                return self.getTypedRuleContext(PiParser.HelperContext,i)


        def newlines(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.NewlinesContext)
            else:
                return self.getTypedRuleContext(PiParser.NewlinesContext,i)


        def getRuleIndex(self):
            return PiParser.RULE_helpers

        def enterRule(self, listener):
            if hasattr(listener, "enterHelpers"):
                listener.enterHelpers(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHelpers"):
                listener.exitHelpers(self)




    def helpers(self):

        localctx = PiParser.HelpersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_helpers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 103
                    self.helper()
                    self.state = 104
                    self.newlines() 
                self.state = 110
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HelperContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.HelperContext, self).__init__(parent, invokingState)
            self.parser = parser

        def procid(self):
            return self.getTypedRuleContext(PiParser.ProcidContext,0)


        def EQ(self):
            return self.getToken(PiParser.EQ, 0)

        def limit(self):
            return self.getTypedRuleContext(PiParser.LimitContext,0)


        def SEM(self):
            return self.getToken(PiParser.SEM, 0)

        def getRuleIndex(self):
            return PiParser.RULE_helper

        def enterRule(self, listener):
            if hasattr(listener, "enterHelper"):
                listener.enterHelper(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitHelper"):
                listener.exitHelper(self)




    def helper(self):

        localctx = PiParser.HelperContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_helper)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 111
            self.procid()
            self.state = 112
            self.match(PiParser.EQ)
            self.state = 113
            self.limit()
            self.state = 114
            self.match(PiParser.SEM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GlobalnamesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.GlobalnamesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def GLOBAL(self):
            return self.getToken(PiParser.GLOBAL, 0)

        def SEM(self):
            return self.getToken(PiParser.SEM, 0)

        def globalname(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.GlobalnameContext)
            else:
                return self.getTypedRuleContext(PiParser.GlobalnameContext,i)


        def getRuleIndex(self):
            return PiParser.RULE_globalnames

        def enterRule(self, listener):
            if hasattr(listener, "enterGlobalnames"):
                listener.enterGlobalnames(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGlobalnames"):
                listener.exitGlobalnames(self)




    def globalnames(self):

        localctx = PiParser.GlobalnamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_globalnames)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(PiParser.GLOBAL)
            self.state = 118 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 117
                self.globalname()
                self.state = 120 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==PiParser.NAME):
                    break

            self.state = 122
            self.match(PiParser.SEM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GlobalnameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.GlobalnameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(PiParser.NAME, 0)

        def getRuleIndex(self):
            return PiParser.RULE_globalname

        def enterRule(self, listener):
            if hasattr(listener, "enterGlobalname"):
                listener.enterGlobalname(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitGlobalname"):
                listener.exitGlobalname(self)




    def globalname(self):

        localctx = PiParser.GlobalnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_globalname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 124
            self.match(PiParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefinitionsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.DefinitionsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def definition(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.DefinitionContext)
            else:
                return self.getTypedRuleContext(PiParser.DefinitionContext,i)


        def newlines(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.NewlinesContext)
            else:
                return self.getTypedRuleContext(PiParser.NewlinesContext,i)


        def getRuleIndex(self):
            return PiParser.RULE_definitions

        def enterRule(self, listener):
            if hasattr(listener, "enterDefinitions"):
                listener.enterDefinitions(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDefinitions"):
                listener.exitDefinitions(self)




    def definitions(self):

        localctx = PiParser.DefinitionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_definitions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 126
                    self.definition()
                    self.state = 127
                    self.newlines() 
                self.state = 133
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefinitionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.DefinitionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def proccalldef(self):
            return self.getTypedRuleContext(PiParser.ProccalldefContext,0)


        def DEF(self):
            return self.getToken(PiParser.DEF, 0)

        def actions(self):
            return self.getTypedRuleContext(PiParser.ActionsContext,0)


        def SEM(self):
            return self.getToken(PiParser.SEM, 0)

        def getRuleIndex(self):
            return PiParser.RULE_definition

        def enterRule(self, listener):
            if hasattr(listener, "enterDefinition"):
                listener.enterDefinition(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDefinition"):
                listener.exitDefinition(self)




    def definition(self):

        localctx = PiParser.DefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_definition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 134
            self.proccalldef()
            self.state = 135
            self.match(PiParser.DEF)
            self.state = 136
            self.actions()
            self.state = 137
            self.match(PiParser.SEM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LimitContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.LimitContext, self).__init__(parent, invokingState)
            self.parser = parser

        def nullprocess(self):
            return self.getTypedRuleContext(PiParser.NullprocessContext,0)


        def newnames(self):
            return self.getTypedRuleContext(PiParser.NewnamesContext,0)


        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def parallels(self):
            return self.getTypedRuleContext(PiParser.ParallelsContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_limit

        def enterRule(self, listener):
            if hasattr(listener, "enterLimit"):
                listener.enterLimit(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLimit"):
                listener.exitLimit(self)




    def limit(self):

        localctx = PiParser.LimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_limit)
        try:
            self.state = 146
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiParser.ZERO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 139
                self.nullprocess()
                pass
            elif token in [PiParser.NEWOP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 140
                self.newnames()
                self.state = 141
                self.match(PiParser.PAROP)
                self.state = 142
                self.parallels()
                self.state = 143
                self.match(PiParser.PARCL)
                pass
            elif token in [PiParser.PROCID, PiParser.PAROP, PiParser.FROP, PiParser.SECRET, PiParser.LEAK]:
                self.enterOuterAlt(localctx, 3)
                self.state = 145
                self.parallels()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NullprocessContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.NullprocessContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ZERO(self):
            return self.getToken(PiParser.ZERO, 0)

        def getRuleIndex(self):
            return PiParser.RULE_nullprocess

        def enterRule(self, listener):
            if hasattr(listener, "enterNullprocess"):
                listener.enterNullprocess(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNullprocess"):
                listener.exitNullprocess(self)




    def nullprocess(self):

        localctx = PiParser.NullprocessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_nullprocess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(PiParser.ZERO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NewnamesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.NewnamesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NEWOP(self):
            return self.getToken(PiParser.NEWOP, 0)

        def names(self):
            return self.getTypedRuleContext(PiParser.NamesContext,0)


        def DOT(self):
            return self.getToken(PiParser.DOT, 0)

        def getRuleIndex(self):
            return PiParser.RULE_newnames

        def enterRule(self, listener):
            if hasattr(listener, "enterNewnames"):
                listener.enterNewnames(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNewnames"):
                listener.exitNewnames(self)




    def newnames(self):

        localctx = PiParser.NewnamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_newnames)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(PiParser.NEWOP)
            self.state = 151
            self.names()
            self.state = 152
            self.match(PiParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParallelsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ParallelsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def comp(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.CompContext)
            else:
                return self.getTypedRuleContext(PiParser.CompContext,i)


        def PARA(self, i=None):
            if i is None:
                return self.getTokens(PiParser.PARA)
            else:
                return self.getToken(PiParser.PARA, i)

        def getRuleIndex(self):
            return PiParser.RULE_parallels

        def enterRule(self, listener):
            if hasattr(listener, "enterParallels"):
                listener.enterParallels(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitParallels"):
                listener.exitParallels(self)




    def parallels(self):

        localctx = PiParser.ParallelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_parallels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.comp()
            self.state = 159
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PiParser.PARA:
                self.state = 155
                self.match(PiParser.PARA)
                self.state = 156
                self.comp()
                self.state = 161
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.CompContext, self).__init__(parent, invokingState)
            self.parser = parser

        def msgout(self):
            return self.getTypedRuleContext(PiParser.MsgoutContext,0)


        def processcall(self):
            return self.getTypedRuleContext(PiParser.ProcesscallContext,0)


        def iterproccall(self):
            return self.getTypedRuleContext(PiParser.IterproccallContext,0)


        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def limit(self):
            return self.getTypedRuleContext(PiParser.LimitContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def sublimit(self):
            return self.getTypedRuleContext(PiParser.SublimitContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_comp

        def enterRule(self, listener):
            if hasattr(listener, "enterComp"):
                listener.enterComp(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComp"):
                listener.exitComp(self)




    def comp(self):

        localctx = PiParser.CompContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_comp)
        try:
            self.state = 170
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 162
                self.msgout()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 163
                self.processcall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 164
                self.iterproccall()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 165
                self.match(PiParser.PAROP)
                self.state = 166
                self.limit()
                self.state = 167
                self.match(PiParser.PARCL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 169
                self.sublimit()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SublimitContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.SublimitContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def limit(self):
            return self.getTypedRuleContext(PiParser.LimitContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def OMEGA(self):
            return self.getToken(PiParser.OMEGA, 0)

        def getRuleIndex(self):
            return PiParser.RULE_sublimit

        def enterRule(self, listener):
            if hasattr(listener, "enterSublimit"):
                listener.enterSublimit(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSublimit"):
                listener.exitSublimit(self)




    def sublimit(self):

        localctx = PiParser.SublimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_sublimit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(PiParser.PAROP)
            self.state = 173
            self.limit()
            self.state = 174
            self.match(PiParser.PARCL)
            self.state = 175
            self.match(PiParser.OMEGA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IterproccallContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.IterproccallContext, self).__init__(parent, invokingState)
            self.parser = parser

        def processcall(self):
            return self.getTypedRuleContext(PiParser.ProcesscallContext,0)


        def OMEGA(self):
            return self.getToken(PiParser.OMEGA, 0)

        def getRuleIndex(self):
            return PiParser.RULE_iterproccall

        def enterRule(self, listener):
            if hasattr(listener, "enterIterproccall"):
                listener.enterIterproccall(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIterproccall"):
                listener.exitIterproccall(self)




    def iterproccall(self):

        localctx = PiParser.IterproccallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_iterproccall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.processcall()
            self.state = 178
            self.match(PiParser.OMEGA)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProccalldefContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ProccalldefContext, self).__init__(parent, invokingState)
            self.parser = parser

        def procid(self):
            return self.getTypedRuleContext(PiParser.ProcidContext,0)


        def BRAOP(self):
            return self.getToken(PiParser.BRAOP, 0)

        def listofvars(self):
            return self.getTypedRuleContext(PiParser.ListofvarsContext,0)


        def BRACL(self):
            return self.getToken(PiParser.BRACL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_proccalldef

        def enterRule(self, listener):
            if hasattr(listener, "enterProccalldef"):
                listener.enterProccalldef(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProccalldef"):
                listener.exitProccalldef(self)




    def proccalldef(self):

        localctx = PiParser.ProccalldefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_proccalldef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.procid()
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PiParser.BRAOP:
                self.state = 181
                self.match(PiParser.BRAOP)
                self.state = 182
                self.listofvars()
                self.state = 183
                self.match(PiParser.BRACL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcesscallContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ProcesscallContext, self).__init__(parent, invokingState)
            self.parser = parser

        def procid(self):
            return self.getTypedRuleContext(PiParser.ProcidContext,0)


        def BRAOP(self):
            return self.getToken(PiParser.BRAOP, 0)

        def listofargs(self):
            return self.getTypedRuleContext(PiParser.ListofargsContext,0)


        def BRACL(self):
            return self.getToken(PiParser.BRACL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_processcall

        def enterRule(self, listener):
            if hasattr(listener, "enterProcesscall"):
                listener.enterProcesscall(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProcesscall"):
                listener.exitProcesscall(self)




    def processcall(self):

        localctx = PiParser.ProcesscallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_processcall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.procid()
            self.state = 192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==PiParser.BRAOP:
                self.state = 188
                self.match(PiParser.BRAOP)
                self.state = 189
                self.listofargs()
                self.state = 190
                self.match(PiParser.BRACL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcidContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ProcidContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PROCID(self):
            return self.getToken(PiParser.PROCID, 0)

        def SECRET(self):
            return self.getToken(PiParser.SECRET, 0)

        def LEAK(self):
            return self.getToken(PiParser.LEAK, 0)

        def getRuleIndex(self):
            return PiParser.RULE_procid

        def enterRule(self, listener):
            if hasattr(listener, "enterProcid"):
                listener.enterProcid(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProcid"):
                listener.exitProcid(self)




    def procid(self):

        localctx = PiParser.ProcidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_procid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PiParser.PROCID) | (1 << PiParser.SECRET) | (1 << PiParser.LEAK))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ActionsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ActionsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def action(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.ActionContext)
            else:
                return self.getTypedRuleContext(PiParser.ActionContext,i)


        def CHOICEOP(self, i=None):
            if i is None:
                return self.getTokens(PiParser.CHOICEOP)
            else:
                return self.getToken(PiParser.CHOICEOP, i)

        def getRuleIndex(self):
            return PiParser.RULE_actions

        def enterRule(self, listener):
            if hasattr(listener, "enterActions"):
                listener.enterActions(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitActions"):
                listener.exitActions(self)




    def actions(self):

        localctx = PiParser.ActionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_actions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.action()
            self.state = 201
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PiParser.CHOICEOP:
                self.state = 197
                self.match(PiParser.CHOICEOP)
                self.state = 198
                self.action()
                self.state = 203
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ActionContext, self).__init__(parent, invokingState)
            self.parser = parser

        def inputpattern(self):
            return self.getTypedRuleContext(PiParser.InputpatternContext,0)


        def DOT(self):
            return self.getToken(PiParser.DOT, 0)

        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def limit(self):
            return self.getTypedRuleContext(PiParser.LimitContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_action

        def enterRule(self, listener):
            if hasattr(listener, "enterAction"):
                listener.enterAction(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAction"):
                listener.exitAction(self)




    def action(self):

        localctx = PiParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.inputpattern()
            self.state = 205
            self.match(PiParser.DOT)
            self.state = 206
            self.match(PiParser.PAROP)
            self.state = 207
            self.limit()
            self.state = 208
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InputpatternContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.InputpatternContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INOP(self):
            return self.getToken(PiParser.INOP, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def listofvars(self):
            return self.getTypedRuleContext(PiParser.ListofvarsContext,0)


        def COL(self):
            return self.getToken(PiParser.COL, 0)

        def pattern(self):
            return self.getTypedRuleContext(PiParser.PatternContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_inputpattern

        def enterRule(self, listener):
            if hasattr(listener, "enterInputpattern"):
                listener.enterInputpattern(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInputpattern"):
                listener.exitInputpattern(self)




    def inputpattern(self):

        localctx = PiParser.InputpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_inputpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(PiParser.INOP)
            self.state = 214
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 211
                self.listofvars()
                self.state = 212
                self.match(PiParser.COL)


            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << PiParser.NAME) | (1 << PiParser.PUBOP) | (1 << PiParser.ENCOP) | (1 << PiParser.ADECOP) | (1 << PiParser.VERIOP) | (1 << PiParser.CURLOP) | (1 << PiParser.PAROP))) != 0):
                self.state = 216
                self.pattern()


            self.state = 219
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.NamesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def newname(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.NewnameContext)
            else:
                return self.getTypedRuleContext(PiParser.NewnameContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PiParser.COMMA)
            else:
                return self.getToken(PiParser.COMMA, i)

        def getRuleIndex(self):
            return PiParser.RULE_names

        def enterRule(self, listener):
            if hasattr(listener, "enterNames"):
                listener.enterNames(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNames"):
                listener.exitNames(self)




    def names(self):

        localctx = PiParser.NamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_names)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.newname()
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PiParser.COMMA:
                self.state = 222
                self.match(PiParser.COMMA)
                self.state = 223
                self.newname()
                self.state = 228
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NewnameContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.NewnameContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(PiParser.NAME, 0)

        def getRuleIndex(self):
            return PiParser.RULE_newname

        def enterRule(self, listener):
            if hasattr(listener, "enterNewname"):
                listener.enterNewname(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNewname"):
                listener.exitNewname(self)




    def newname(self):

        localctx = PiParser.NewnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_newname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 229
            self.match(PiParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListofargsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ListofargsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def arguments(self):
            return self.getTypedRuleContext(PiParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_listofargs

        def enterRule(self, listener):
            if hasattr(listener, "enterListofargs"):
                listener.enterListofargs(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitListofargs"):
                listener.exitListofargs(self)




    def listofargs(self):

        localctx = PiParser.ListofargsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_listofargs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.arguments()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ArgumentsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(PiParser.ArgumentContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PiParser.COMMA)
            else:
                return self.getToken(PiParser.COMMA, i)

        def getRuleIndex(self):
            return PiParser.RULE_arguments

        def enterRule(self, listener):
            if hasattr(listener, "enterArguments"):
                listener.enterArguments(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitArguments"):
                listener.exitArguments(self)




    def arguments(self):

        localctx = PiParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.argument()
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==PiParser.COMMA:
                self.state = 234
                self.match(PiParser.COMMA)
                self.state = 235
                self.argument()
                self.state = 240
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ArgumentContext, self).__init__(parent, invokingState)
            self.parser = parser

        def msg(self):
            return self.getTypedRuleContext(PiParser.MsgContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_argument

        def enterRule(self, listener):
            if hasattr(listener, "enterArgument"):
                listener.enterArgument(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitArgument"):
                listener.exitArgument(self)




    def argument(self):

        localctx = PiParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.msg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListofvarsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.ListofvarsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def variables(self):
            return self.getTypedRuleContext(PiParser.VariablesContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_listofvars

        def enterRule(self, listener):
            if hasattr(listener, "enterListofvars"):
                listener.enterListofvars(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitListofvars"):
                listener.exitListofvars(self)




    def listofvars(self):

        localctx = PiParser.ListofvarsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_listofvars)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.variables()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariablesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.VariablesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(PiParser.VariableContext,0)


        def sizedvar(self):
            return self.getTypedRuleContext(PiParser.SizedvarContext,0)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(PiParser.COMMA)
            else:
                return self.getToken(PiParser.COMMA, i)

        def variables(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.VariablesContext)
            else:
                return self.getTypedRuleContext(PiParser.VariablesContext,i)


        def getRuleIndex(self):
            return PiParser.RULE_variables

        def enterRule(self, listener):
            if hasattr(listener, "enterVariables"):
                listener.enterVariables(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariables"):
                listener.exitVariables(self)




    def variables(self):

        localctx = PiParser.VariablesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_variables)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiParser.NAME]:
                self.state = 245
                self.variable()
                pass
            elif token in [PiParser.PAROP]:
                self.state = 246
                self.sizedvar()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 253
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 249
                    self.match(PiParser.COMMA)
                    self.state = 250
                    self.variables() 
                self.state = 255
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.VariableContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(PiParser.NAME, 0)

        def getRuleIndex(self):
            return PiParser.RULE_variable

        def enterRule(self, listener):
            if hasattr(listener, "enterVariable"):
                listener.enterVariable(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariable"):
                listener.exitVariable(self)




    def variable(self):

        localctx = PiParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.match(PiParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SizedvarContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.SizedvarContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def variable(self):
            return self.getTypedRuleContext(PiParser.VariableContext,0)


        def COL(self):
            return self.getToken(PiParser.COL, 0)

        def SIZE(self):
            return self.getToken(PiParser.SIZE, 0)

        def size(self):
            return self.getTypedRuleContext(PiParser.SizeContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_sizedvar

        def enterRule(self, listener):
            if hasattr(listener, "enterSizedvar"):
                listener.enterSizedvar(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSizedvar"):
                listener.exitSizedvar(self)




    def sizedvar(self):

        localctx = PiParser.SizedvarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_sizedvar)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self.match(PiParser.PAROP)
            self.state = 259
            self.variable()
            self.state = 260
            self.match(PiParser.COL)
            self.state = 261
            self.match(PiParser.SIZE)
            self.state = 262
            self.size()
            self.state = 263
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SizeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.SizeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(PiParser.NUMBER, 0)

        def getRuleIndex(self):
            return PiParser.RULE_size

        def enterRule(self, listener):
            if hasattr(listener, "enterSize"):
                listener.enterSize(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSize"):
                listener.exitSize(self)




    def size(self):

        localctx = PiParser.SizeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_size)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self.match(PiParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MsgoutContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.MsgoutContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FROP(self):
            return self.getToken(PiParser.FROP, 0)

        def msg(self):
            return self.getTypedRuleContext(PiParser.MsgContext,0)


        def FRCL(self):
            return self.getToken(PiParser.FRCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_msgout

        def enterRule(self, listener):
            if hasattr(listener, "enterMsgout"):
                listener.enterMsgout(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMsgout"):
                listener.exitMsgout(self)




    def msgout(self):

        localctx = PiParser.MsgoutContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_msgout)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 267
            self.match(PiParser.FROP)
            self.state = 268
            self.msg()
            self.state = 269
            self.match(PiParser.FRCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.MsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def pairmsg(self):
            return self.getTypedRuleContext(PiParser.PairmsgContext,0)


        def encrymsg(self):
            return self.getTypedRuleContext(PiParser.EncrymsgContext,0)


        def aencrymsg(self):
            return self.getTypedRuleContext(PiParser.AencrymsgContext,0)


        def signmsg(self):
            return self.getTypedRuleContext(PiParser.SignmsgContext,0)


        def pubkeymsg(self):
            return self.getTypedRuleContext(PiParser.PubkeymsgContext,0)


        def basicmsg(self):
            return self.getTypedRuleContext(PiParser.BasicmsgContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_msg

        def enterRule(self, listener):
            if hasattr(listener, "enterMsg"):
                listener.enterMsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitMsg"):
                listener.exitMsg(self)




    def msg(self):

        localctx = PiParser.MsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_msg)
        try:
            self.state = 277
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiParser.PAROP]:
                self.enterOuterAlt(localctx, 1)
                self.state = 271
                self.pairmsg()
                pass
            elif token in [PiParser.ENCOP, PiParser.CURLOP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 272
                self.encrymsg()
                pass
            elif token in [PiParser.AENCOP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 273
                self.aencrymsg()
                pass
            elif token in [PiParser.SIGNOP]:
                self.enterOuterAlt(localctx, 4)
                self.state = 274
                self.signmsg()
                pass
            elif token in [PiParser.PUBOP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 275
                self.pubkeymsg()
                pass
            elif token in [PiParser.NAME]:
                self.enterOuterAlt(localctx, 6)
                self.state = 276
                self.basicmsg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BasicmsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.BasicmsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(PiParser.NAME, 0)

        def getRuleIndex(self):
            return PiParser.RULE_basicmsg

        def enterRule(self, listener):
            if hasattr(listener, "enterBasicmsg"):
                listener.enterBasicmsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBasicmsg"):
                listener.exitBasicmsg(self)




    def basicmsg(self):

        localctx = PiParser.BasicmsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_basicmsg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self.match(PiParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EncrymsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.EncrymsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ENCOP(self):
            return self.getToken(PiParser.ENCOP, 0)

        def msg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.MsgContext)
            else:
                return self.getTypedRuleContext(PiParser.MsgContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def CURLOP(self):
            return self.getToken(PiParser.CURLOP, 0)

        def CURLCL(self):
            return self.getToken(PiParser.CURLCL, 0)

        def UNDER(self):
            return self.getToken(PiParser.UNDER, 0)

        def getRuleIndex(self):
            return PiParser.RULE_encrymsg

        def enterRule(self, listener):
            if hasattr(listener, "enterEncrymsg"):
                listener.enterEncrymsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitEncrymsg"):
                listener.exitEncrymsg(self)




    def encrymsg(self):

        localctx = PiParser.EncrymsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_encrymsg)
        try:
            self.state = 293
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [PiParser.ENCOP]:
                self.enterOuterAlt(localctx, 1)
                self.state = 281
                self.match(PiParser.ENCOP)
                self.state = 282
                self.msg()
                self.state = 283
                self.match(PiParser.COMMA)
                self.state = 284
                self.msg()
                self.state = 285
                self.match(PiParser.PARCL)
                pass
            elif token in [PiParser.CURLOP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 287
                self.match(PiParser.CURLOP)
                self.state = 288
                self.msg()
                self.state = 289
                self.match(PiParser.CURLCL)
                self.state = 290
                self.match(PiParser.UNDER)
                self.state = 291
                self.msg()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AencrymsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.AencrymsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def AENCOP(self):
            return self.getToken(PiParser.AENCOP, 0)

        def msg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.MsgContext)
            else:
                return self.getTypedRuleContext(PiParser.MsgContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_aencrymsg

        def enterRule(self, listener):
            if hasattr(listener, "enterAencrymsg"):
                listener.enterAencrymsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAencrymsg"):
                listener.exitAencrymsg(self)




    def aencrymsg(self):

        localctx = PiParser.AencrymsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_aencrymsg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.match(PiParser.AENCOP)
            self.state = 296
            self.msg()
            self.state = 297
            self.match(PiParser.COMMA)
            self.state = 298
            self.msg()
            self.state = 299
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SignmsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.SignmsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def SIGNOP(self):
            return self.getToken(PiParser.SIGNOP, 0)

        def msg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.MsgContext)
            else:
                return self.getTypedRuleContext(PiParser.MsgContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_signmsg

        def enterRule(self, listener):
            if hasattr(listener, "enterSignmsg"):
                listener.enterSignmsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSignmsg"):
                listener.exitSignmsg(self)




    def signmsg(self):

        localctx = PiParser.SignmsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_signmsg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 301
            self.match(PiParser.SIGNOP)
            self.state = 302
            self.msg()
            self.state = 303
            self.match(PiParser.COMMA)
            self.state = 304
            self.msg()
            self.state = 305
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PubkeymsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.PubkeymsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PUBOP(self):
            return self.getToken(PiParser.PUBOP, 0)

        def msg(self):
            return self.getTypedRuleContext(PiParser.MsgContext,0)


        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_pubkeymsg

        def enterRule(self, listener):
            if hasattr(listener, "enterPubkeymsg"):
                listener.enterPubkeymsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPubkeymsg"):
                listener.exitPubkeymsg(self)




    def pubkeymsg(self):

        localctx = PiParser.PubkeymsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_pubkeymsg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.match(PiParser.PUBOP)
            self.state = 308
            self.msg()
            self.state = 309
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PairmsgContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.PairmsgContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PAROP(self):
            return self.getToken(PiParser.PAROP, 0)

        def msg(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.MsgContext)
            else:
                return self.getTypedRuleContext(PiParser.MsgContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_pairmsg

        def enterRule(self, listener):
            if hasattr(listener, "enterPairmsg"):
                listener.enterPairmsg(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPairmsg"):
                listener.exitPairmsg(self)




    def pairmsg(self):

        localctx = PiParser.PairmsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_pairmsg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(PiParser.PAROP)
            self.state = 312
            self.msg()
            self.state = 313
            self.match(PiParser.COMMA)
            self.state = 314
            self.msg()
            self.state = 315
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.PatternContext, self).__init__(parent, invokingState)
            self.parser = parser

        def pairmsg(self):
            return self.getTypedRuleContext(PiParser.PairmsgContext,0)


        def encrymsg(self):
            return self.getTypedRuleContext(PiParser.EncrymsgContext,0)


        def adecpattern(self):
            return self.getTypedRuleContext(PiParser.AdecpatternContext,0)


        def veripattern(self):
            return self.getTypedRuleContext(PiParser.VeripatternContext,0)


        def pubkeymsg(self):
            return self.getTypedRuleContext(PiParser.PubkeymsgContext,0)


        def basicmsg(self):
            return self.getTypedRuleContext(PiParser.BasicmsgContext,0)


        def variable(self):
            return self.getTypedRuleContext(PiParser.VariableContext,0)


        def getRuleIndex(self):
            return PiParser.RULE_pattern

        def enterRule(self, listener):
            if hasattr(listener, "enterPattern"):
                listener.enterPattern(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPattern"):
                listener.exitPattern(self)




    def pattern(self):

        localctx = PiParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_pattern)
        try:
            self.state = 324
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 317
                self.pairmsg()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 318
                self.encrymsg()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 319
                self.adecpattern()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 320
                self.veripattern()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 321
                self.pubkeymsg()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 322
                self.basicmsg()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 323
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AdecpatternContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.AdecpatternContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ADECOP(self):
            return self.getToken(PiParser.ADECOP, 0)

        def pattern(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.PatternContext)
            else:
                return self.getTypedRuleContext(PiParser.PatternContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_adecpattern

        def enterRule(self, listener):
            if hasattr(listener, "enterAdecpattern"):
                listener.enterAdecpattern(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAdecpattern"):
                listener.exitAdecpattern(self)




    def adecpattern(self):

        localctx = PiParser.AdecpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_adecpattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 326
            self.match(PiParser.ADECOP)
            self.state = 327
            self.pattern()
            self.state = 328
            self.match(PiParser.COMMA)
            self.state = 329
            self.pattern()
            self.state = 330
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VeripatternContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.VeripatternContext, self).__init__(parent, invokingState)
            self.parser = parser

        def VERIOP(self):
            return self.getToken(PiParser.VERIOP, 0)

        def pattern(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(PiParser.PatternContext)
            else:
                return self.getTypedRuleContext(PiParser.PatternContext,i)


        def COMMA(self):
            return self.getToken(PiParser.COMMA, 0)

        def PARCL(self):
            return self.getToken(PiParser.PARCL, 0)

        def getRuleIndex(self):
            return PiParser.RULE_veripattern

        def enterRule(self, listener):
            if hasattr(listener, "enterVeripattern"):
                listener.enterVeripattern(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVeripattern"):
                listener.exitVeripattern(self)




    def veripattern(self):

        localctx = PiParser.VeripatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_veripattern)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 332
            self.match(PiParser.VERIOP)
            self.state = 333
            self.pattern()
            self.state = 334
            self.match(PiParser.COMMA)
            self.state = 335
            self.pattern()
            self.state = 336
            self.match(PiParser.PARCL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NewlinesContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(PiParser.NewlinesContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self, i=None):
            if i is None:
                return self.getTokens(PiParser.NEWLINE)
            else:
                return self.getToken(PiParser.NEWLINE, i)

        def getRuleIndex(self):
            return PiParser.RULE_newlines

        def enterRule(self, listener):
            if hasattr(listener, "enterNewlines"):
                listener.enterNewlines(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNewlines"):
                listener.exitNewlines(self)




    def newlines(self):

        localctx = PiParser.NewlinesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_newlines)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(PiParser.NEWLINE)
            self.state = 342
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,22,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 339
                    self.match(PiParser.NEWLINE) 
                self.state = 344
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,22,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





